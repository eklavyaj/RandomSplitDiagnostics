df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(20) # ------------------ rejected --------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
# ------------------------ diamonds -----------------------------------------
set.seed(2) # --------------------------- accepted --------------------------
# data preparation
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
source('~/BTP/BTP-Optimal-Split/run.R')
library(RandomSplitDiagnostics)
set.seed(15)
# data preparation
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
# --------------------------- rejected -------------------------
set.seed(16)
# data preparation
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
set.seed(3) # ------------------ accepted ---------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(20) # ------------------ rejected --------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
set.seed(3) # ------------------ accepted ---------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(20) # ------------------ rejected --------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(3) # ------------------ accepted ---------------------------------
library(RandomSplitDiagnostics)
set.seed(3) # ------------------ accepted ---------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(20) # ------------------ rejected --------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
set.seed(20) # ------------------ rejected --------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Ring ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(20) # ------------------ rejected --------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(20) # ------------------ rejected --------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, num.simulations = 1000,
alpha = 0.05, save.plots = FALSE)
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
# ------------------------ abalone -----------------------------------------
set.seed(3) # ------------------ accepted ---------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(20) # ------------------ rejected --------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
# ------------------------ diamonds -----------------------------------------
set.seed(2) # --------------------------- accepted --------------------------
# data preparation
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
# ------------------------ abalone -----------------------------------------
set.seed(3) # ------------------ accepted ---------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(20) # ------------------ rejected --------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
# ------------------------ diamonds -----------------------------------------
set.seed(2) # --------------------------- accepted --------------------------
# data preparation
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
set.seed(3) # ------------------ accepted ---------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(3) # ------------------ accepted ---------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(20) # ------------------ rejected --------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(2) # --------------------------- accepted --------------------------
# data preparation
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
set.seed(3) # ------------------ accepted ---------------------------------
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
setwd("~/BTP/BTP-Optimal-Split/vizualization/drop_in_model_performance")
source('~/BTP/BTP-Optimal-Split/vizualization/drop_in_model_performance/drop1.R')
source('~/BTP/BTP-Optimal-Split/vizualization/drop_in_model_performance/drop2.R')
source('~/BTP/BTP-Optimal-Split/vizualization/drop_in_model_performance/drop2.R')
source('~/BTP/BTP-Optimal-Split/vizualization/drop_in_model_performance/drop1.R')
source('~/BTP/BTP-Optimal-Split/vizualization/drop_in_model_performance/drop1.R')
setwd("~/BTP/BTP-Optimal-Split/vizualization/splitting")
source('~/BTP/BTP-Optimal-Split/vizualization/splitting/visualize.R')
data <- read.csv("sports - Sheet2.csv")
source('~/BTP/BTP-Optimal-Split/vizualization/splitting/visualize.R')
library(prospectr)
library(RandomSplitDiagnostics)
dataset.name <- "abalone"
num_cols <- unlist(lapply(abalone, is.numeric))
abalone <- abalone[, num_cols]
model.relation <- Rings ~ LongestShell + Diameter + Height
idx <- kenStone(abalone, k = floor(0.8*nrow(abalone)), metric = "mahal")
df.test = abalone[idx$test, ]
df.train = abalone[idx$model, ]
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 2000,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
idx <- kenStone(abalone, k = floor(0.8*nrow(abalone)), metric = "mahal")
df.test = abalone[idx$test, ]
df.train = abalone[-idx$test, ]
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 2000,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
source('~/BTP/BTP-Optimal-Split/run.R')
# --------------------------- rejected -------------------------
for (i in 1:20){
set.seed(i)
# data preparation
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# initial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
}
