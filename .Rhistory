data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
df.train
head(df.train)
lm(model.relation, data = df.train)
lm(price ~ x:y:z + depth, data = df.train)
library(RandomSplitDiagnostics)
library(RandomSplitDiagnostics)
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
set.seed(19)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(20)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Outp
ut")
library(RandomSplitDiagnostics)
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
df <- read.csv("../../../Downloads/Life Expectancy Data.csv")
df.kernel()
df
colnames(df)
model.relation <- Life.expectancy ~ Population + percentage.expenditure + BMI + Schooling
s <- sample(x = 1:nrow(df), size = floor(nrow(df)*0.8), replace = F)
df.train <- df[s, ]
df.test <- df[-s, ]
diagnose("Expectancy", df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
df
is.na(df)
use_package("stats")
library(devtools)
use_package("stats")
use_package("fpc")
use_r("temp5")
use_package("ggplot2")
use_package("reshape2")
use_package('stringr')
library(RandomSplitDiagnostics)
remove(stats)
remove.packages("stats")
detach("package:stats", unload = TRUE)
library(RandomSplitDiagnostics)
example("diagnose", ""RandomSplitDiagnostics"")
example("diagnose", "RandomSplitDiagnostics")
library(stats, lib.loc = "/usr/lib/R/library")
example("diagnose", "RandomSplitDiagnostics")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
model.matrix(model.relation, df.test)
colnames(model.matrix(model.relation, df.test))
model.relation = WholeWeight ~ Height + LongestShell + diameter
model.matrix(model.relation, df.test)
model.matrix(model.relation, df.test)
model.relation = WholeWeight ~ Height + LongestShell + Diameter
model.matrix(model.relation, df.test)
model.relation = WholeWeight ~ Height + LongestShell + diameter
model.matrix(model.relation, df.test)
model.relation = WholeWeight ~ Height + longestShell + diameter
model.matrix(model.relation, df.test)
df.test[[response.var]]
response.var <- stringr::str_trim(strsplit(deparse(model.relation), "\\~")[[1]][1])
df.test[[response.var]]
response.var
response.var = "whole"
df.test[[response.var]]
# data preparation
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
model.matrix(model.relation, df.test)
# data preparation
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ X:y:z + depth
model.matrix(model.relation, df.test)
?RandomSplitDiagnostics
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
abalone
data(abalone)
abalone
plot(abalone)
# data preparation
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
# data preparation
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
# data preparation
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(20)
# data preparation
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
# data preparation
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
response.var <- stringr::str_trim(strsplit(deparse(model.relation), "\\~")[[1]][1])
model <- glm(model.relation, data = df.train)
train.data <- as.data.frame(model.matrix(model))[-c(1)]
test.data <- as.data.frame(model.matrix(model.relation, df.test))[-c(1)]
train.predictions <- predict(model, df.train)
train.actual <- df.train[[response.var]]
test.predictions <- predict(model, df.test)
test.actual <- df.test[[response.var]]
train.predictions
model
summary(model)
train.predictions <- predict(model, df.train, type = "response")
train.predictions
response.var <- stringr::str_trim(strsplit(deparse(model.relation), "\\~")[[1]][1])
model <- glm(model.relation, family = "binomial", data = df.train)
model <- glm(model.relation, family = "gaussian", data = df.train)
train.data <- as.data.frame(model.matrix(model))[-c(1)]
test.data <- as.data.frame(model.matrix(model.relation, df.test))[-c(1)]
train.predictions <- predict(model, df.train)
train.actual <- df.train[[response.var]]
test.predictions <- predict(model, df.test)
test.actual <- df.test[[response.var]]
train.predictions
df.train[[response.var]] = factor(df.train[[response.var]])
model <- glm(model.relation, family = "binomial", data = df.train)
train.data <- as.data.frame(model.matrix(model))[-c(1)]
model <- glm(model.relation, family = "gaussian", data = df.train)
df.train[[response.var]]
isna(df.train[[response.var]])
any(is.na(df.train[[response.var]]))
hist(df.train[[response.var]])
plot(df.train[[response.var]])
df.train[[response.var]]
model <- glm(model.relation, family = "gaussian", data = df.train)
model <- glm(model.relation, family = "multinomial", data = df.train)
model <- glm(model.relation, family = "ordinal", data = df.train)
model <- glm(model.relation, family = multinomial, data = df.train)
model <- nnet::multinom(model.relation, data = df.train)
train.data <- as.data.frame(model.matrix(model))[-c(1)]
test.data <- as.data.frame(model.matrix(model.relation, df.test))[-c(1)]
train.predictions <- predict(model, df.train)
train.actual <- df.train[[response.var]]
test.predictions <- predict(model, df.test)
test.actual <- df.test[[response.var]]
train.predictions
train.actual
train.performance <- calculate_performance(train.actual, train.predictions, nrow(df.train),
num.variables, metric.performance)
num.variables <- ncol(train.data) + 1
train.performance <- calculate_performance(train.actual, train.predictions, nrow(df.train),
num.variables, metric.performance)
calculate_performance <- function(actual, prediction, n, k, metric.performance = "Normalized AIC"){
performance <- 0
act <- as.numeric(actual)
pred <- as.numeric(prediction)
if (metric.performance == "Normalized AIC"){
rss <- sum((act-pred)**2)
k <- k + 1
performance <- log(rss/n) + 2*k/n
}
return(performance)
}
train.performance <- calculate_performance(train.actual, train.predictions, nrow(df.train),
num.variables, metric.performance)
test.performance <- calculate_performance(test.actual, test.predictions, nrow(df.test),
num.variables, metric.performance)
train.data[[response.var]] <- df.train[[response.var]]
test.data[[response.var]] <- df.test[[response.var]]
distance <- calculate_distance(train.data, test.data)
distance
num_cols <- unlist(lapply(train, is.numeric))
train.performance
test.performance
library(RandomSplitDiagnostics)
# data preparation
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
model <- nnet::multinom(model.relation, data = df.train)
train.data <- as.data.frame(model.matrix(model))[-c(1)]
test.data <- as.data.frame(model.matrix(model.relation, df.test))[-c(1)]
train.predictions <- predict(model, df.train)
train.actual <- df.train[[response.var]]
response.var <- stringr::str_trim(strsplit(deparse(model.relation), "\\~")[[1]][1])
train.actual <- df.train[[response.var]]
train.predictions
df.train
summary(df.train)
library(RandomSplitDiagnostics)
# data preparation
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
set.seed(20)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- Rings ~ LongestShell + Diameter + Height
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
