ggplot2::geom_vline(ggplot2::aes(xintercept = initial.distance, colour = "Distance (d)"),
linetype="dashed", size = 1) +
ggplot2::scale_color_manual(name = "Distances",
values = c("Threshold 1 (c1)" = "#006CFF",
"Threshold 2 (c2)" = "#FF0000",
"Distance (d)" = "#03B621")) +
ggplot2::theme_bw() +
ggplot2::labs(x = "Modified Mahalanobis Distance", y = "Density",
title = "Parameter Evaluation Plot",
subtitle = subtitle,
caption = paste("Distance Values :","c1 =", round(c1, 2),
", d =", round(initial.distance, 2),
", c2 =", round(c2, 2))) +
ggplot2::theme(plot.subtitle = ggplot2::element_text(color = "red"))
threshold.plot
if (initial.distance >= c1 & initial.distance <= c2){
subtitle <- latex2exp::TeX(sprintf(r'(Null Hypothesis with $\alpha = %d$ accepted since $|c_1| < |d| < |c_2|$)', alpha))
# subtitle <- paste("Null Hypothesis with", latex2exp::TeX(r'($\alpha$)'), "=", alpha, "accepted since |c1| < |d| < |c2|")
} else{
if (initial.distance <= c1){
subtitle <- latex2exp::TeX(sprintf(r'(Null Hypothesis with $\alpha = %d$ rejected since $|d| \leq |c_1|$)', alpha))
# "Null Hypothesis with", (r'($\alpha$)'), "=", alpha, "rejected since |d| <= |c1|"
} else{
subtitle <- latex2exp::TeX(sprintf(r'(Null Hypothesis with $\alpha = %d$ rejected since $|d| \geq |c_1|$)', alpha))
# subtitle <- paste("Null Hypothesis with", latex2exp::TeX(r'($\alpha$)'), "=", alpha, "rejected since |d| >= |c2|")
}
}
df.distance <- data.frame(distance = d.vec)
density.plot <- ggplot2::ggplot(df.distance, ggplot2::aes(x = distance)) + ggplot2::geom_density()
df.to_fill <- data.frame(x = ggplot2::ggplot_build(density.plot)$data[[1]]$x,
y = ggplot2::ggplot_build(density.plot)$data[[1]]$y)
threshold.plot <- density.plot +
ggplot2::geom_area(data = df.to_fill[df.to_fill$x <= c1, ],
ggplot2::aes(x = x, y = y),
fill = "#D16103", alpha = 0.3) +
ggplot2::geom_area(data = df.to_fill[df.to_fill$x >= c2, ],
ggplot2::aes(x = x, y = y),
fill = "#D16103", alpha = 0.3 ) +
ggplot2::geom_area(data = df.to_fill[df.to_fill$x <= c2 & df.to_fill$x >= c1, ],
ggplot2::aes(x = x, y = y),
fill = "#4E84C4", alpha = 0.3) +
ggplot2::scale_fill_manual(name = "Regions",
values = c("Acceptance" = "#CDE2FA",
"Rejection" = "#FFB16F")) +
ggplot2::geom_vline(ggplot2::aes(xintercept = thresholds[1], colour = ("Threshold 1 ($\\c_1$)")),
linetype="dashed", size = 1) +
ggplot2::geom_vline(ggplot2::aes(xintercept = thresholds[2], colour = "Threshold 2 (c2)"),
linetype="dashed", size = 1) +
ggplot2::geom_vline(ggplot2::aes(xintercept = initial.distance, colour = "Distance (d)"),
linetype="dashed", size = 1) +
ggplot2::scale_color_manual(name = "Distances",
values = c("Threshold 1 (c1)" = "#006CFF",
"Threshold 2 (c2)" = "#FF0000",
"Distance (d)" = "#03B621")) +
ggplot2::theme_bw() +
ggplot2::labs(x = "Modified Mahalanobis Distance", y = "Density",
title = "Parameter Evaluation Plot",
subtitle = subtitle,
caption = paste("Distance Values :","c1 =", round(c1, 2),
", d =", round(initial.distance, 2),
", c2 =", round(c2, 2))) +
ggplot2::theme(plot.subtitle = ggplot2::element_text(color = "red"))
threshold.plot
if (save.plots){
filename <- paste0(output.dir, "/", dataset.name, "_threshold_plot.tex")
ggplot2::ggsave(filename, plot = threshold.plot, bg = "white")
print(paste("Threshold Plot saved @", filename))
}
save.plots = TRUE
if (save.plots){
filename <- paste0(output.dir, "/", dataset.name, "_threshold_plot.tex")
ggplot2::ggsave(filename, plot = threshold.plot, bg = "white")
print(paste("Threshold Plot saved @", filename))
}
output.dir = ""
if (save.plots){
filename <- paste0(output.dir, "/", dataset.name, "_threshold_plot.tex")
ggplot2::ggsave(filename, plot = threshold.plot, bg = "white")
print(paste("Threshold Plot saved @", filename))
}
if (save.plots){
filename <- paste0(output.dir, "/", dataset.name, "_threshold_plot.tex")
tikzDevice::tikz(file = filename)
print(threshold.plot)
dev.off()
# ggplot2::ggsave(filename, plot = threshold.plot, bg = "white")
print(paste("Threshold Plot saved @", filename))
}
install.packages("tikzDevice")
if (save.plots){
filename <- paste0(output.dir, "/", dataset.name, "_threshold_plot.tex")
tikzDevice::tikz(file = filename)
print(threshold.plot)
dev.off()
# ggplot2::ggsave(filename, plot = threshold.plot, bg = "white")
print(paste("Threshold Plot saved @", filename))
}
output.dir =
"Output"
if (save.plots){
filename <- paste0(output.dir, "/", dataset.name, "_threshold_plot.tex")
tikzDevice::tikz(file = filename)
print(threshold.plot)
dev.off()
# ggplot2::ggsave(filename, plot = threshold.plot, bg = "white")
print(paste("Threshold Plot saved @", filename))
}
library(RandomSplitDiagnostics)
# data preparation
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, flag.simulate = TRUE,
model.relation = model.relation, metric.performance = "Normalized AIC",
num.simulations = 200, flag.find_threshold = TRUE, num.bootstrap = 1000,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
# data preparation
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, flag.simulate = TRUE,
model.relation = model.relation, metric.performance = "Normalized AIC",
num.simulations = 200, flag.find_threshold = TRUE, num.bootstrap = 1000,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
test.data <- as.data.frame(model.matrix(model.relation, df.test))[-c(1)]
test.data
library(RandomSplitDiagnostics)
# data preparation
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, flag.simulate = TRUE,
model.relation = model.relation, metric.performance = "Normalized AIC",
num.simulations = 200, flag.find_threshold = TRUE, num.bootstrap = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
# data preparation
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, flag.simulate = TRUE,
model.relation = model.relation, metric.performance = "Normalized AIC",
num.simulations = 200, flag.find_threshold = TRUE, num.bootstrap = 1000,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
if (model.relation != ""){
response.var <- stringr::str_trim(strsplit(deparse(model.relation), "\\~")[[1]][1])
train.response <- df.train[[response.var]]
test.response <- df.train[[response.var]]
df.train <- as.data.frame(model.matrix(model.relation, df.train))[-c(1)]
df.test <- as.data.frame(model.matrix(model.relation, df.test))[-c(1)]
df.train[[response.var]] <- train.response
df.test[[response.var]] <- test.response
}
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
response.var <- stringr::str_trim(strsplit(deparse(model.relation), "\\~")[[1]][1])
train.response <- df.train[[response.var]]
test.response <- df.train[[response.var]]
df.train <- as.data.frame(model.matrix(model.relation, df.train))[-c(1)]
df.test <- as.data.frame(model.matrix(model.relation, df.test))[-c(1)]
df.train
df.test
train.response
df.train[[response.var]] <- train.response
df.train
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, flag.simulate = TRUE,
model.relation = model.relation, metric.performance = "Normalized AIC",
num.simulations = 200, flag.find_threshold = TRUE, num.bootstrap = 1000,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
library(RandomSplitDiagnostics)
?diagnose
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
library(RandomSplitDiagnostics)
set.seed(20)
example("diagnose", "RandomSplitDiagnostics")
library(RandomSplitDiagnostics)
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
diamonds
diamonds$x
print(model.relation)
[-c(1)]
test.data <- as.data.frame(model.matrix(model.relation, df.test))[-c(1)]
test.data
library(RandomSplitDiagnostics)
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
df.train
head(df.train)
lm(model.relation, data = df.train)
lm(price ~ x:y:z + depth, data = df.train)
library(RandomSplitDiagnostics)
library(RandomSplitDiagnostics)
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
set.seed(19)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
set.seed(20)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
# defining model relation based on variables of data
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Outp
ut")
library(RandomSplitDiagnostics)
dataset.name <- "Diamonds"
data(diamonds)
split.percentage <- 0.8
# intial random split of data
s <- sample(x = 1:nrow(diamonds), size = floor(nrow(diamonds)*split.percentage), replace = F)
df.train <- diamonds[s, ]
df.test <- diamonds[-s, ]
# defining model relation based on variables of data
model.relation <- price ~ x:y:z + depth
# function call
diagnose(dataset.name, df.train, df.test, model.relation = model.relation,
metric.performance = "Normalized AIC", num.simulations = 200,
alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
?diagnose
?diagnose
?diagnose
?diagnose
devtools::load_all(".")
set.seed(19)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
diagnose(dataset.name, df.train, df.test, model.relation = model.relation, metric.performance = "Normalized AIC", num.simulations = 200, alpha = 0.05, save.plots = TRUE, output.dir = "Output")
install.packages('Rcpp')
install.packages("Rcpp")
diagnose(dataset.name, df.train, df.test, model.relation = model.relation, metric.performance = "Normalized AIC", num.simulations = 200, alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
set.seed(19)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
df.train
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
diagnose(dataset.name, df.train, df.test, model.relation = model.relation, metric.performance = "Normalized AIC", num.simulations = 200, alpha = 0.05, save.plots = TRUE, output.dir = "Output")
install.packages("latex2exp")
library(RandomSplitDiagnostics)
set.seed(19)
dataset.name <- "Abalone"
data(abalone)
split.percentage <- 0.8
s <- sample(x = 1:nrow(abalone), size = floor(nrow(abalone)*split.percentage), replace = F)
df.train <- abalone[s, ]
df.test <- abalone[-s, ]
model.relation <- WholeWeight ~ Height + LongestShell + Diameter
diagnose(dataset.name, df.train, df.test, model.relation = model.relation, metric.performance = "Normalized AIC", num.simulations = 200, alpha = 0.05, save.plots = TRUE, output.dir = "Output")
library(RandomSplitDiagnostics)
